---
layout: post
title:  2019/4/9 学习笔记
date:   2019-4-9 20:05:00 +0800
categories: 文章
tag: interview
---

* content
{:toc}
# 反汇编再学习

《IDA Pro权威指南》：为了满足所有要求，反汇编器必须从大量算法中选择一些适当的算法，来处理我们提供的文件。

## 基本的反汇编算法

1. 确定进行反汇编的代码区域。通常，指令与数据混杂在一起，区分它们就显得非常重要。以最常见的情形——反汇编可执行文件为例，该文件必须符合可执行文件的某种通用格式，如Windows所用的可移植可执行（PE）格式或许多UNIX系统常用的可执行和链接格式（ELF）。这些格式通常含有一种机制，用来确定文件中包含代码和代码入口点的部分的位置（通常变现为层级文件头的形式）。
2. 知道指令的起始地址后，下一步就是读取该地址（或文件偏移量）所包含的值，并执行一次表查找，将二进制操作码的值与它的汇编语言助记符对应起来。
3. 获取指令并解码任何所需的操作数后，需要对它的汇编语言等价形式进行格式化，并将其在反汇编代码中输出。
4. 输出一条指令后，继续反汇编下一条指令，并重复上述过程，直到反汇编完文件中的所有指令。
5. 有大量算法可以用于确定从何处开始反汇编、如何选择下一条反汇编的指令、如何区分代码与数据，以及如何确定何时完成对最后一条指令的反汇编。线性扫描和递归下降是两种最主要的反汇编算法。

### 1.线性扫描

原理:一条指令结束，另一条指令开始

关键:确定起始位置 

流程:从起始，逐条反汇编指令，直到完成整个代码段

优点:  可覆盖程序的所有代码段

缺陷: 如果代码段中混有数据！

gdb windbg objdump均采用线性扫描

###  2.递归下降

原理:根据一条指令是否被另一条指令引用来决定是否对其进行反汇编

- 顺序流指令：直接解析它后面的下一条指令，如MOV、PUSH、POP

- 条件分支指令：解析它的所有条件路径，如JNZ

- 无条件分支指令：反汇编器会尝试定位到跳转的目标，但有可能失败（如JMP EAX,EAX在静态环境下无法确认)

- 函数调用指令：和无条件分支指令相似，如CALL EAX

优点：可以区别代码和数据

IDA使用的是递归遍历反汇编算法



